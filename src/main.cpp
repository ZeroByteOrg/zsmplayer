#include "x16sound.h"
#include "zsm.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <chrono>
#include <thread>

//char filename[] = "SONIC.ZSM";
char* filename;
float YMrate;
float PSGrate;
float ym_remain;
float psg_remain;

// returns -1 = music not playing, 0=buffer full, 1=done and music is playing
int tick() {
	int buffer_full=0;
	unsigned int r;
	if (ym_remain < 1 && psg_remain < 1) {
		if (!zsm_tick()) return -1;
		ym_remain += YMrate;
		psg_remain += PSGrate;
	}
	//TODO: Queue up the chip writes generated by zsm_tick() and then dole them
	//      out as one ym write per ym audio frame, advancing PSG by the floating
	//      point amount of audio frames in parallel. If PSG write, just dump them
	//      all - do this while writes remain in the queue. This is because the
	//      YM track is slightly out-of-sync with the VERA track thanks to the
	//      one write per frame requirement of YMFM.
	r = x16sound_render(CHIP_YM, floor(ym_remain));
	ym_remain -= r;
	r = x16sound_render(CHIP_PSG, floor(psg_remain));
	psg_remain -= r;
	buffer_full = (ym_remain >= 1 || psg_remain >= 1) ? 1 : 0;
	return !buffer_full;
}

// returns 0=music not playing, 1=music still playing
int fill_buffer() {
	int result;
	do {
		result=tick();
	} while (result==1);
	return (result==0);
}

void loopcontrol() {
	printf ("looped!!! yay.\n");
}

int main(int argc, char *argv[]) {
	int i=0;
	zsm=NULL;
	zsm_onloop(&loopcontrol);
	while (++i<argc) {
		if (!x16sound_init()) return -2;
		filename=argv[i];
		if (!load_zsm(filename)) {
			printf ("Unable to load %s.",filename);
			continue;
		};
		YMrate = (float)YM_samplerate(YM_CLOCK)/(float)(*(unsigned short*)&zsm[0x0c]);
		PSGrate = (float)(PSG_SAMPLERATE)/(float)(*(unsigned short*)&zsm[0x0c]);
		ym_remain = 0;
		psg_remain = 0;
		fill_buffer();
		if (!x16sound_start_audio()) return -3;
		printf ("Playing %s.\n",filename);
		while (tick()>=0) {
#ifndef NOSLEEP // for Win32 cross compile - need to find an alternative sleep aid. ;)
			using std::chrono::operator""ms;
			std::this_thread::sleep_until(std::chrono::steady_clock::now() + 10ms);
#endif
		}
		x16sound_empty_buffer();
		x16sound_stop_audio();
	}
	printf("shutting down...\n");
  x16sound_shutdown();

	return 0;
}
